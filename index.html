<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HYPERKILL — HTML5 Boomer Shooter</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0a0a0a; color:#f0f0f0; font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #ui { position:fixed; inset:0; pointer-events:none; }
    .hud { position:absolute; left:16px; bottom:16px; display:flex; gap:12px; align-items:flex-end; }
    .panel { background:rgba(0,0,0,0.45); backdrop-filter: blur(4px); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:10px 12px; box-shadow:0 8px 24px rgba(0,0,0,0.35); }
    .stat { font-weight:700; font-size:14px; letter-spacing:0.5px; }
    .big { font-size:28px; line-height:1; }
    .small { font-size:12px; opacity:0.8 }
    #crosshair { position:absolute; left:50%; top:50%; width:16px; height:16px; margin:-8px 0 0 -8px; filter: drop-shadow(0 0 2px #000); }
    #crosshair:before, #crosshair:after { content:""; position:absolute; background:#fafafa; }
    #crosshair:before { left:7px; top:0; width:2px; height:16px; }
    #crosshair:after { top:7px; left:0; width:16px; height:2px; }
    #centerText { position:absolute; left:50%; top:15%; transform:translateX(-50%); text-align:center; font-weight:800; font-size:32px; letter-spacing:1px; text-shadow:0 2px 12px rgba(0,0,0,0.6); }
    #alerts { position:absolute; right:16px; bottom:16px; display:flex; flex-direction:column; gap:8px; }
    .alert { pointer-events:none; animation: fadeOut 1.2s ease forwards; }
    @keyframes fadeOut { 0%{opacity:1; transform:translateY(0)} 100%{opacity:0; transform:translateY(10px)} }
    #title { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; gap:18px; background:radial-gradient(1200px 800px at 50% 35%, rgba(255,255,255,0.05), transparent 60%), #070707; z-index:10; }
    #title h1 { margin:0; font-size:64px; letter-spacing:2px; }
    #title button { pointer-events:auto; padding:14px 20px; border-radius:14px; border:1px solid #2b2b2b; background:#101010; color:#fff; font-weight:800; letter-spacing:0.8px; cursor:pointer; transition:transform .08s ease; }
    #title button:hover { transform:translateY(-1px); }
    #controls { white-space:pre; text-align:left; opacity:0.9; font-size:13px; }
    #damageVignette { position:fixed; inset:0; pointer-events:none; background:radial-gradient(800px 800px at 50% 50%, rgba(255,0,0,0.0), rgba(255,0,0,0.25) 70%); opacity:0; transition:opacity .12s ease; }
    #styleMeter { position:absolute; left:50%; top:8%; transform:translateX(-50%); display:flex; align-items:center; gap:10px; }
    #styleBar { width:380px; height:10px; background:rgba(255,255,255,0.08); border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,0.08) }
    #styleFill { height:100%; width:0%; background:linear-gradient(90deg, #9ef, #f9f); box-shadow:0 0 24px rgba(153,204,255,0.35) inset; }
    #grade { font-weight:900; font-size:22px; letter-spacing:1px; min-width:40px; text-align:center; }
    #reticleDot { position:absolute; left:50%; top:50%; width:4px; height:4px; margin:-2px 0 0 -2px; background:#fff; border-radius:50%; opacity:0.6 }
    .killfeed { position:absolute; right:16px; top:16px; display:flex; flex-direction:column; gap:6px; }
    .killItem { font-weight:800; font-size:14px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.1); padding:6px 8px; border-radius:8px; animation:fadeOut 1.8s ease forwards; }
    .weaponPanel { display:flex; gap:8px; }
    .weapon { padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.08); background:rgba(255,255,255,0.06); font-size:12px; font-weight:800; opacity:0.7 }
    .weapon.active { outline:2px solid #fff; opacity:1 }
    #pause { position:fixed; inset:0; display:none; z-index:20; background:rgba(0,0,0,0.7); align-items:center; justify-content:center; }
    #pause .card { background:#0e0e0e; border:1px solid #2c2c2c; border-radius:16px; padding:22px; max-width:480px; }
    #pause h2 { margin-top:0 }
    #pause button { margin-top:12px; padding:10px 14px; border-radius:10px; border:1px solid #2b2b2b; background:#101010; color:#fff; font-weight:800; cursor:pointer; }
  </style>
</head>
<body>
  <div id="title">
    <h1>HYPERKILL</h1>
    <div id="controls" class="panel">
WASD = Move | Mouse = Look
Space = Jump (double-jump)
Shift = Dash | Ctrl = Slide | C = Toggle Crouch
1 = Pistol | 2 = Shotgun | 3 = Punch
R = Reload | Esc = Pause
Left Click = Fire / Punch | Right Click = Alternate
    </div>
    <button id="startBtn">Click to Play</button>
    <div class="small">Original assets. Fast arena shooter, not affiliated with ULTRAKILL.</div>
  </div>
  <div id="ui">
    <div id="crosshair"></div>
    <div id="reticleDot"></div>
    <div id="centerText"></div>
    <div id="styleMeter">
      <div id="grade">D</div>
      <div id="styleBar"><div id="styleFill"></div></div>
    </div>
    <div class="killfeed" id="killfeed"></div>
    <div class="hud">
      <div class="panel">
        <div class="small">HEALTH</div>
        <div id="hp" class="big">100</div>
      </div>
      <div class="panel">
        <div class="small">AMMO</div>
        <div id="ammo" class="big">12 / ∞</div>
      </div>
      <div class="panel">
        <div class="small">STYLE</div>
        <div id="styleScore" class="big">0</div>
      </div>
      <div class="panel weaponPanel" id="weapons">
        <div class="weapon active" data-idx="0">Pistol</div>
        <div class="weapon" data-idx="1">Shotgun</div>
        <div class="weapon" data-idx="2">Punch</div>
      </div>
    </div>
    <div id="alerts"></div>
  </div>
  <div id="damageVignette"></div>
  <div id="pause">
    <div class="card">
      <h2>Paused</h2>
      <p>Press <b>Esc</b> to resume.</p>
      <button id="resumeBtn">Resume</button>
      <button id="resetBtn">Restart Arena</button>
    </div>
  </div>
  
  <script type="module">
    // Using Three.js via CDN (procedural models only; no external assets)
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

    /********************
     * Utility helpers  *
     ********************/
    const clamp = (v, a, b)=>Math.min(Math.max(v,a),b);
    const rand = (a=0,b=1)=>a+Math.random()*(b-a);
    const lerp = (a,b,t)=>a+(b-a)*t;

    function addAlert(msg){
      const el=document.createElement('div');
      el.className='alert panel';
      el.textContent=msg;
      document.getElementById('alerts').appendChild(el);
      setTimeout(()=>el.remove(), 1200);
    }
    function killfeed(msg){
      const el=document.createElement('div');
      el.className='killItem';
      el.textContent=msg;
      document.getElementById('killfeed').prepend(el);
      setTimeout(()=>el.remove(), 1800);
    }

    /********************
     * Audio (generated) *
     ********************/
    const actx = new (window.AudioContext || window.webkitAudioContext)();
    function beep({freq=440, dur=0.08, type='square', gain=0.06}){
      const o=actx.createOscillator();
      const g=actx.createGain();
      o.type=type; o.frequency.value=freq;
      g.gain.value=gain; o.connect(g); g.connect(actx.destination);
      o.start(); o.stop(actx.currentTime+dur);
    }
    function playShot(){beep({freq:120, dur:0.06, type:'square', gain:0.08});}
    function playRail(){beep({freq:600, dur:0.05, type:'sawtooth', gain:0.06});}
    function playPunch(){beep({freq:90, dur:0.05, type:'triangle', gain:0.07});}
    function playHit(){beep({freq:300, dur:0.05, type:'square', gain:0.04});}
    function playHurt(){beep({freq:80, dur:0.12, type:'sine', gain:0.12});}
    function playDash(){beep({freq:260, dur:0.06, type:'triangle', gain:0.05});}

    /********************
     * Scene setup       *
     ********************/
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0e13);

    const camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 6);

    // Arena lighting
    const hemi = new THREE.HemisphereLight(0xbfd7ff, 0x0b0b0b, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.35); dir.position.set(4,10,2); scene.add(dir);

    // Pointer lock controls
    const controls = new PointerLockControls(camera, renderer.domElement);

    // Minimal gun model (procedural)
    const gun = new THREE.Group();
    const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.12,0.6), new THREE.MeshStandardMaterial({color:0x22262e, metalness:0.2, roughness:0.6}));
    gunBody.position.set(0.25,-0.2,-0.6);
    const gunBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.08,0.4), new THREE.MeshStandardMaterial({color:0x3d4350, metalness:0.4, roughness:0.5}));
    gunBarrel.position.set(0.25,-0.18,-0.95);
    gun.add(gunBody); gun.add(gunBarrel);
    camera.add(gun);
    scene.add(camera);

    // Floor & arena (procedural)
    const floorMat = new THREE.MeshStandardMaterial({color:0x121418, metalness:0.1, roughness:0.9});
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(120,120), floorMat);
    floor.rotation.x = -Math.PI/2; scene.add(floor);

    // Walls / blocks
    const world = [];
    function addBlock(x,y,z, sx,sy,sz, color=0x1a1f27){
      const m = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), new THREE.MeshStandardMaterial({color, metalness:0.05, roughness:0.9}));
      m.position.set(x,y,z); m.receiveShadow=true; m.castShadow=true; scene.add(m); world.push(m);
    }
    // Build a simple arena maze
    for(let i=0;i<10;i++){
      addBlock(rand(-40,40), 1.5, rand(-40,40), rand(2,7), 3, rand(2,7), 0x161a20);
    }
    // Perimeter walls
    addBlock(0,2,-60, 120,4,2);
    addBlock(0,2,60, 120,4,2);
    addBlock(-60,2,0, 2,4,120);
    addBlock(60,2,0, 2,4,120);

    // Simple enemy prefab (capsule)
    function makeEnemy(pos){
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.35,0.9, 6,10), new THREE.MeshStandardMaterial({color:0xbd2b2b, metalness:0.1, roughness:0.7}));
      const eye = new THREE.Mesh(new THREE.SphereGeometry(0.12,16,16), new THREE.MeshStandardMaterial({color:0xffffff, emissive:0x660000, emissiveIntensity:0.6}));
      eye.position.set(0,0.35,0.32); body.add(eye);
      g.add(body);
      g.position.copy(pos);
      g.userData = { hp: 100, speed: rand(2.2, 3.2), grounded:true, vel:new THREE.Vector3(), lastHit:0, dead:false };
      scene.add(g);
      enemies.push(g);
      return g;
    }

    // Spawn enemies
    const enemies = [];
    function spawnWave(n=8){
      for(let i=0;i<n;i++){
        makeEnemy(new THREE.Vector3(rand(-40,40), 1.0, rand(-40,40)));
      }
    }

    /********************
     * Player physics   *
     ********************/
    const keys = {}; let wantCrouch=false; let slideTimer=0; let dashCD=0; let canDouble=true;
    const player = {
      pos: new THREE.Vector3(0,1.6,6),
      vel: new THREE.Vector3(),
      onGround: false,
      hp: 100,
      maxHP: 100,
      height: 1.6,
    };

    let lastTime = performance.now();
    const GRAV = 20, FRICTION = 8, ACCEL = 50, AIRACCEL = 18, MAXSPEED = 10, AIRSPEED=8, JUMP=6.5, DASH=18;

    function tryMove(dt){
      // basis from camera yaw
      const yaw = camera.rotation.y; // valid because PointerLockControls modifies camera.rotation
      const fwd = new THREE.Vector3(Math.sin(yaw),0,-Math.cos(yaw));
      const right = new THREE.Vector3(fwd.z,0,-fwd.x);

      let wish = new THREE.Vector3();
      if(keys['KeyW']) wish.add(fwd);
      if(keys['KeyS']) wish.sub(fwd);
      if(keys['KeyA']) wish.sub(right);
      if(keys['KeyD']) wish.add(right);
      if(wish.lengthSq()>0) wish.normalize();

      const accel = player.onGround ? ACCEL : AIRACCEL;
      const max = player.onGround ? MAXSPEED : AIRSPEED;

      // slide mechanics
      if((keys['ControlLeft']||keys['ControlRight']||wantCrouch) && player.onGround){
        slideTimer = Math.min(slideTimer+dt, 0.3);
        wish.multiplyScalar(1.3);
      } else {
        slideTimer = Math.max(slideTimer-dt*2, 0);
      }

      // accelerate
      const current = player.vel.clone(); current.y=0;
      const add = wish.multiplyScalar(accel*dt);
      current.add(add);
      current.clampLength(0, max + (slideTimer>0?4:0));
      player.vel.x = current.x; player.vel.z = current.z;

      // gravity & friction
      if(player.onGround){
        player.vel.x -= player.vel.x * Math.min(1, FRICTION*dt);
        player.vel.z -= player.vel.z * Math.min(1, FRICTION*dt);
      } else {
        player.vel.y -= GRAV * dt;
      }

      // dash
      if(keys['ShiftLeft'] && dashCD<=0){
        const dir2D = new THREE.Vector3(player.vel.x,0,player.vel.z);
        if(dir2D.lengthSq()<1e-3){
          const yaw = camera.rotation.y;
          dir2D.set(Math.sin(yaw),0,-Math.cos(yaw));
        } else dir2D.normalize();
        player.vel.add(dir2D.multiplyScalar(DASH));
        dashCD = 0.6; playDash(); addAlert('DASH');
        keys['ShiftLeft']=false; // consume
      }
      dashCD -= dt;

      // integrate
      player.pos.addScaledVector(player.vel, dt);
      // simple ground collision with floor and boxes
      // floor
      if(player.pos.y < 1.0){ player.pos.y = 1.0; player.vel.y=0; player.onGround=true; canDouble=true; }
      else player.onGround=false;

      // clamp to arena bounds
      player.pos.x = clamp(player.pos.x, -58, 58);
      player.pos.z = clamp(player.pos.z, -58, 58);

      // primitive collision with blocks (AABB vs capsule)
      const r = 0.35; // player radius
      const eye = player.pos.clone();
      for(const b of world){
        const min = b.position.clone().addScalar(0); const max = min.clone();
        const sx = b.geometry.parameters.width || b.geometry.parameters.parameters.width;
        const sy = b.geometry.parameters.height || b.geometry.parameters.parameters.height;
        const sz = b.geometry.parameters.depth || b.geometry.parameters.parameters.depth;
        min.x -= sx/2; min.y -= sy/2; min.z -= sz/2;
        max.x += sx/2; max.y += sy/2; max.z += sz/2;
        // find closest point to player's feet/torso
        const p = eye.clone(); p.y = clamp(p.y, min.y, max.y);
        const closest = new THREE.Vector3(clamp(eye.x, min.x, max.x), p.y, clamp(eye.z, min.z, max.z));
        const diff = eye.clone().sub(closest);
        const d2 = diff.lengthSq();
        if(d2 < r*r){
          const d = Math.sqrt(Math.max(1e-6, d2));
          const push = diff.multiplyScalar((r-d)/Math.max(1e-3, d));
          player.pos.add(push);
        }
      }

      camera.position.copy(player.pos);
    }

    // Jump & crouch toggles
    function doJump(){
      if(player.onGround){ player.vel.y = JUMP; player.onGround=false; }
      else if(canDouble){ player.vel.y = JUMP; canDouble=false; addAlert('DOUBLE JUMP'); }
    }

    /********************
     * Weapons & combat *
     ********************/
    const Weapons = {
      PISTOL: 0,
      SHOTGUN: 1,
      PUNCH: 2,
    };
    let currentWeapon = 0;

    const pistol = { ammo: 12, mag:12, reserve:Infinity, cooldown:0, rof:0.22, dmg:34 };
    const shotgun = { ammo: 6, mag:6, reserve:Infinity, cooldown:0, rof:0.65, pellets:9, spread:0.07, dmg:12 };

    function setWeapon(i){ currentWeapon=i; [...document.querySelectorAll('.weapon')].forEach(w=>w.classList.remove('active')); document.querySelector(`[data-idx="${i}"]`).classList.add('active'); updateAmmoUI(); }

    function updateAmmoUI(){
      let text='';
      if(currentWeapon===Weapons.PISTOL) text = `${pistol.ammo} / ∞`;
      else if(currentWeapon===Weapons.SHOTGUN) text = `${shotgun.ammo} / ∞`;
      else text = '—';
      document.getElementById('ammo').textContent = text;
    }

    // Raycast helper
    const raycaster = new THREE.Raycaster();
    function raycastFromCenter(spread=0){
      const x = 0 + (Math.random()-0.5)*spread;
      const y = 0 + (Math.random()-0.5)*spread;
      const mouse = new THREE.Vector2(x,y);
      raycaster.setFromCamera(mouse, camera);
      const candidates = [...enemies, ...world];
      const hits = raycaster.intersectObjects(candidates, true);
      return hits[0] || null;
    }

    // Blood particles (procedural)
    const particles = [];
    const pgeo = new THREE.SphereGeometry(0.02, 6,6);
    function spawnBlood(pos, count=8){
      for(let i=0;i<count;i++){
        const m = new THREE.Mesh(pgeo, new THREE.MeshStandardMaterial({color:0x991111, metalness:0.0, roughness:1.0}));
        m.position.copy(pos);
        m.userData = { vel: new THREE.Vector3(rand(-1,1), rand(1,3), rand(-1,1)), life: rand(0.4, 1.0) };
        scene.add(m); particles.push(m);
      }
    }

    // Style system (original)
    let style = 0; let lastKillTime=0; const styleFill = document.getElementById('styleFill'); const gradeEl = document.getElementById('grade'); const styleScoreEl = document.getElementById('styleScore');
    function addStyle(amount, tag){
      const now = performance.now()/1000;
      if(now-lastKillTime<2.5) amount*=1.25; // combo bonus
      style = clamp(style+amount, 0, 1000);
      lastKillTime = now;
      styleFill.style.width = `${Math.min(100, style/10)}%`;
      const g = style>=800?'SS': style>=600?'S': style>=400?'A': style>=250?'B': style>=120?'C':'D';
      gradeEl.textContent = g;
      styleScoreEl.textContent = Math.floor(style);
      if(tag) killfeed(tag);
    }

    function damageEnemy(enemy, dmg, hitPoint){
      if(enemy.userData.dead) return;
      enemy.userData.hp -= dmg;
      spawnBlood(hitPoint, rand(3,6)|0);
      playHit();
      if(enemy.userData.hp<=0){
        enemy.userData.dead=true; scene.remove(enemy);
        const airborne = !player.onGround ? 50:0; const speedBonus = player.vel.length()>9 ? 40:0;
        addStyle(100 + airborne + speedBonus, `ELIMINATED +${100+airborne+speedBonus}`);
      }
    }

    function doFire(){
      if(currentWeapon===Weapons.PUNCH){ playPunch(); // short-range melee sweep
        const hit = raycastFromCenter(0.02);
        if(hit && enemies.includes(hit.object.parent||hit.object)){
          const root = enemies.find(e=>e===hit.object || e===hit.object.parent);
          if(root) damageEnemy(root, 60, hit.point);
        }
        return; }

      if(currentWeapon===Weapons.PISTOL){ if(pistol.cooldown>0 || pistol.ammo<=0) return; pistol.cooldown=pistol.rof; pistol.ammo--; updateAmmoUI(); playShot();
        const hit = raycastFromCenter(0.005);
        if(hit){
          const root = enemies.find(e=>e===hit.object || e===hit.object.parent);
          if(root){ damageEnemy(root, pistol.dmg, hit.point); }
        }
        return; }

      if(currentWeapon===Weapons.SHOTGUN){ if(shotgun.cooldown>0 || shotgun.ammo<=0) return; shotgun.cooldown=shotgun.rof; shotgun.ammo--; updateAmmoUI(); playShot();
        for(let i=0;i<shotgun.pellets;i++){
          const hit = raycastFromCenter(shotgun.spread);
          if(hit){
            const root = enemies.find(e=>e===hit.object || e===hit.object.parent);
            if(root){ damageEnemy(root, shotgun.dmg, hit.point); }
          }
        }
      }
    }

    function reload(){ if(currentWeapon===Weapons.PISTOL){ pistol.ammo=pistol.mag; updateAmmoUI(); addAlert('RELOAD'); }
      if(currentWeapon===Weapons.SHOTGUN){ shotgun.ammo=shotgun.mag; updateAmmoUI(); addAlert('RELOAD'); } }

    /********************
     * Game loop         *
     ********************/
    function update(dt){
      tryMove(dt);

      pistol.cooldown-=dt; shotgun.cooldown-=dt;

      // Enemies AI
      const ppos = player.pos.clone();
      for(const e of enemies){
        if(e.userData.dead) continue;
        const to = ppos.clone().sub(e.position); const dist = to.length(); to.normalize();
        e.userData.vel.addScaledVector(to, e.userData.speed*dt);
        e.position.addScaledVector(to, e.userData.speed*dt);
        // Simple attack
        if(dist<1.0){ if(Math.random()<0.02){ damagePlayer(10); e.position.addScaledVector(to, -0.6); } }
        // keep on floor
        e.position.y = 1.0;
      }

      // particles
      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i]; p.userData.life-=dt; p.position.addScaledVector(p.userData.vel, dt); p.userData.vel.y -= GRAV*0.5*dt; if(p.position.y<0.02){ p.userData.vel.multiplyScalar(0.3); p.position.y=0.02; }
        p.material.opacity = clamp(p.userData.life, 0, 1); p.material.transparent=true;
        if(p.userData.life<=0){ scene.remove(p); particles.splice(i,1); }
      }

      // Minor gun sway
      const t = performance.now()*0.002; gun.position.x = 0.25 + Math.sin(t)*0.02; gun.position.y = -0.2 + (player.onGround?Math.sin(t*2)*0.01:0.02);
    }

    function damagePlayer(d){
      player.hp = Math.max(0, player.hp - d);
      document.getElementById('hp').textContent = player.hp;
      const dmg = document.getElementById('damageVignette'); dmg.style.opacity=0.8; setTimeout(()=>dmg.style.opacity=0, 100);
      playHurt(); if(player.hp<=0) gameOver();
    }

    function gameOver(){
      addAlert('YOU DIED — Press Reset');
      paused = true; document.exitPointerLock?.();
      document.getElementById('pause').style.display='flex';
    }

    let paused = false;
    function loop(){
      const now = performance.now(); const dt = Math.min(0.033, (now-lastTime)/1000); lastTime = now;
      if(!paused){ update(dt); renderer.render(scene, camera); }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    /********************
     * Spawning/Reset    *
     ********************/
    function resetGame(){
      // remove old enemies
      for(const e of enemies){ scene.remove(e); }
      enemies.length=0;
      spawnWave(10);
      player.pos.set(0,1.6,6); player.vel.set(0,0,0); player.hp=100; document.getElementById('hp').textContent=player.hp;
      pistol.ammo=pistol.mag; shotgun.ammo=shotgun.mag; updateAmmoUI();
      style=0; styleFill.style.width='0%'; gradeEl.textContent='D'; styleScoreEl.textContent='0';
      addAlert('NEW WAVE');
    }

    /********************
     * Input             *
     ********************/
    window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    window.addEventListener('keydown', (e)=>{
      keys[e.code]=true;
      if(e.code==='Space'){ e.preventDefault(); doJump(); }
      if(e.code==='KeyC'){ wantCrouch=!wantCrouch; }
      if(e.code==='Digit1') setWeapon(0);
      if(e.code==='Digit2') setWeapon(1);
      if(e.code==='Digit3') setWeapon(2);
      if(e.code==='KeyR') reload();
      if(e.code==='Escape'){ togglePause(); }
    });
    window.addEventListener('keyup', (e)=>{ keys[e.code]=false; });
    window.addEventListener('mousedown', (e)=>{ if(document.pointerLockElement!==renderer.domElement) return; if(e.button===0) doFire(); });
    window.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });

    function togglePause(){
      paused=!paused; const p=document.getElementById('pause');
      if(paused){ p.style.display='flex'; document.exitPointerLock?.(); }
      else { p.style.display='none'; renderer.domElement.requestPointerLock?.(); actx.resume?.(); }
    }

    document.getElementById('resumeBtn').onclick=()=>togglePause();
    document.getElementById('resetBtn').onclick=()=>{ resetGame(); paused=false; document.getElementById('pause').style.display='none'; renderer.domElement.requestPointerLock?.(); };

    document.getElementById('startBtn').addEventListener('click', ()=>{
      document.getElementById('title').style.display='none';
      renderer.domElement.requestPointerLock?.();
      actx.resume?.();
      resetGame();
    });

    // Click to resume pointer lock
    renderer.domElement.addEventListener('click', ()=>{
      if(document.pointerLockElement!==renderer.domElement && !paused){ renderer.domElement.requestPointerLock?.(); actx.resume?.(); }
    });

    // Pointer lock look handling
    let yaw=0, pitch=0;
    document.addEventListener('mousemove', (e)=>{
      if(document.pointerLockElement!==renderer.domElement) return;
      yaw -= e.movementX * 0.0025; pitch -= e.movementY * 0.0025;
      pitch = clamp(pitch, -Math.PI/2+0.01, Math.PI/2-0.01);
      camera.rotation.set(pitch, yaw, 0, 'YXZ');
    });

  </script>
</body>
</html>
